from fastapi import APIRouter, Depends, HTTPException, Header, status
from sqlalchemy.orm import Session
from typing import List
from database import get_db
from config import settings
from models import Product, Bundle
from schemas import FeedItemCreate, FeedItemResponse
from utils import create_slug, sanitize_multiline_urls
import httpx
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/feed-items", tags=["api"])

async def verify_api_key(x_eve_api_key: str = Header(...)):
    if x_eve_api_key != settings.eve_api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API Key"
        )
    return x_eve_api_key

@router.post("", response_model=FeedItemResponse)
async def create_feed_item(
    payload: FeedItemCreate,
    db: Session = Depends(get_db),
    _ = Depends(verify_api_key)
):
    """
    Create a new feed item (bundle of products) directly via API.
    Used by Eve app for automation.
    """
    try:
        # Add request logging as specified
        logger.info(f"POST /api/feed-items hit")
        
        # Generate default title if not provided
        if payload.title is None:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            payload.title = f"Eve Look - {timestamp}"
            logger.info(f"Generated default title: {payload.title}")
        else:
            logger.info(f"Creating feed item: {payload.title} with {len(payload.links)} links")
        
        # 1. Create Products
        products = []
        timeout = httpx.Timeout(3.0, connect=3.0, read=3.0, write=3.0)
        headers = {"User-Agent": "Channel3-LinkSanitizer/1.0 (+https://trychannel3.com)"}
        
        async with httpx.AsyncClient(follow_redirects=True, timeout=timeout, headers=headers) as client:
            # Join all links into a single multiline string
            raw_links = "\n".join(payload.links)
            
            # Sanitize the multiline string (resolves Channel 3 links, fetches titles, etc.)
            sanitized_urls = await sanitize_multiline_urls(raw_links, client)
            
            # Create a SINGLE product containing all links
            slug = create_slug(db, Product, payload.title)
            product = Product(
                slug=slug,
                title=payload.title,
                image_url=payload.image_url,
                product_url=sanitized_urls, # Store all links here
                is_published=True, # Publish this single card
                feed=payload.feed
            )
            db.add(product)
            products.append(product)
        
        # 2. Create Bundle
        bundle_slug = create_slug(db, Bundle, payload.title)
        bundle = Bundle(
            slug=bundle_slug,
            title=payload.title,
            description=f"Look generated by Eve",
            is_published=True,
            feed=payload.feed,
            products=products
        )
        db.add(bundle)
        
        db.commit()
        db.refresh(bundle)
        
        # 3. Return response
        # Assuming public feed URL format: /public/bundle/{slug}/page
        # Adjust based on actual frontend routing
        public_url = f"/public/bundle/{bundle.slug}/page"
        
        # Create response using field names (not aliases)
        # With allow_population_by_field_name=True, this should work
        response_data = {
            "item_id": bundle.id,
            "public_feed_url": public_url,
            "success": True,
            "message": "Feed item created successfully"
        }
        
        # Validate and return the response
        return FeedItemResponse(**response_data)
        
    except Exception as e:
        logger.error(f"Error creating feed item: {e}", exc_info=True)
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))
